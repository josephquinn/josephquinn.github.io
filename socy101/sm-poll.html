<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Live Poll</title>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
    :root{
      /* Dark background that complements your palette */
      --bg0: #0b1020;
      --bg1: #08121a;
      --text: rgba(255,255,255,0.92);
      --muted: rgba(255,255,255,0.72);

      /* Frosted cards */
      --card: rgba(255,255,255,0.12);
      --card2: rgba(255,255,255,0.16);
      --border: rgba(255,255,255,0.22);
      --shadow: 0 18px 60px rgba(0,0,0,0.35);
      --radius: 18px;

      /* Your categorical palette */
      --c1: #003b49;
      --c2: #1d4289;
      --c3: #d3273e;
      --c4: #1b365d;
      --c5: #5d3754;
      --c6: #007a78;
    }

    *{ box-sizing: border-box; }
    body{
      margin: 0;
      min-height: 100vh;

      display: flex;
      align-items: center;
      justify-content: center;

      background:
        radial-gradient(1200px 900px at 20% 10%, rgba(29,66,137,0.22), transparent 55%),
        radial-gradient(1200px 900px at 80% 20%, rgba(0,122,120,0.18), transparent 55%),
        radial-gradient(900px 700px at 50% 90%, rgba(211,39,62,0.12), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--text);
      padding: 22px;
    }

    .wrap{
      width: 100%;
      max-width: 1100px;

      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr);
      gap: 18px;

      margin: auto;
    }
    @media (max-width: 900px){
      body{ align-items: flex-start; }
      .wrap{ grid-template-columns: 1fr; }
    }

    .card{
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 18px;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      min-width: 0;
    }

    .title{
      font-size: 14px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--muted);
      margin: 0 0 8px;
    }
    .question{
      font-size: clamp(20px, 2.5vw, 30px);
      line-height: 1.15;
      font-weight: 760;
      margin: 0 0 10px;
    }
    .sub{
      margin: 0 0 12px;
      color: var(--muted);
      font-size: 14px;
    }

    .options{
      display: grid;
      gap: 10px;
      margin-top: 10px;
    }

    .opt{
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      user-select: none;
      background: rgba(255,255,255,0.10);
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease;
      display: grid;
      grid-template-columns: 34px 1fr;
      gap: 10px;
      min-width: 0;
    }
    .opt:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.13);
      border-color: rgba(255,255,255,0.28);
    }
    .opt.selected{
      border-color: rgba(29,66,137,0.70);
      box-shadow: 0 0 0 5px rgba(29,66,137,0.16);
      background: rgba(255,255,255,0.15);
    }

    .badge{
      width: 34px;
      height: 34px;
      border-radius: 10px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 850;
      color: rgba(255,255,255,0.96);
      background: rgba(29,66,137,0.40);
      border: 1px solid rgba(29,66,137,0.40);
      flex: 0 0 auto;
    }

    .label{
      font-size: 16px;
      font-weight: 680;
      line-height: 1.2;
      color: rgba(255,255,255,0.92);
      align-self: center;
      word-break: break-word;
    }

    .actions{
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 14px;
      flex-wrap: wrap;
    }

    button{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 14px;
      padding: 10px 12px;
      font-weight: 780;
      cursor: pointer;
      transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, opacity 120ms ease;
    }
    button:hover{
      transform: translateY(-1px);
      background: rgba(255,255,255,0.13);
      border-color: rgba(255,255,255,0.26);
    }
    button:disabled{
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }
    .primary{
      background: rgba(29,66,137,0.38);
      border-color: rgba(29,66,137,0.48);
    }

    .status{
      margin-left: auto;
      display:flex;
      gap:8px;
      align-items:center;
      font-size: 13px;
      color: var(--muted);
    }
    .dot{
      width: 10px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.35);
    }
    .dot.live{
      background: var(--c6);
      box-shadow: 0 0 0 6px rgba(0,122,120,0.16);
    }

    .chartWrap{
      height: 420px;
      width: 100%;
      overflow: hidden;
    }
    @media (max-width: 900px){
      .chartWrap{ height: 360px; }
    }

    .footerNote{
      margin-top: 10px;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
    }

    .tiny-secret{
      position: fixed;
      left: 10px;
      bottom: 10px;
      width: 14px;
      height: 14px;
      border-radius: 6px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.18);
      cursor: pointer;
      opacity: 0.35;
      transition: opacity 120ms ease, transform 120ms ease;
      z-index: 9999;
    }
    .tiny-secret:hover{
      opacity: 0.75;
      transform: translateY(-1px);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <section class="card" aria-label="Poll input">
      <p class="title">Live Poll</p>
      <h1 id="qText" class="question">Loading question…</h1>
      <p id="qSub" class="sub">Select all that apply.</p>

      <div id="options" class="options" aria-label="Options"></div>

      <div class="actions">
        <button id="voteBtn" class="primary" disabled>Submit</button>
        <button id="revoteBtn" disabled title="Change your vote on this device">Change vote</button>

        <div class="status" title="Live connection status">
          <span id="liveDot" class="dot"></span>
          <span id="liveText">Connecting…</span>
        </div>
      </div>

      <p class="footerNote">Anonymous • aggregated counts only</p>
    </section>

    <section class="card" aria-label="Results">
      <p class="title">Results</p>
      <div class="chartWrap">
        <canvas id="chart"></canvas>
      </div>
      <p id="countNote" class="footerNote"></p>
    </section>
  </div>

  <div id="secretClear" class="tiny-secret" title="(instructor) clear"></div>

  <script>
/**********************
 * EDIT THESE TWO LINES
 * SCRIPT_URL is the same across all pages.
 * POLL_ID must match the Google Sheet tab name for this poll.
 **********************/
    const SCRIPT_URL = "https://script.google.com/macros/s/YOUR_DEPLOYMENT_ID/exec";
    const POLL_ID = "Choose all - cats";

    const PALETTE = ["#003b49","#1d4289","#d3273e","#1b365d","#5d3754","#007a78"];
    const REFRESH_MS = 1500;
    const LOCAL_LOCK_KEY = `poll_lock_${POLL_ID}`;

    let poll = null;
    let chart = null;

    // multi-select state
    const selected = new Set(); // stores option.value strings

    const elQ = document.getElementById("qText");
    const elSub = document.getElementById("qSub");
    const elOptions = document.getElementById("options");
    const elVote = document.getElementById("voteBtn");
    const elReVote = document.getElementById("revoteBtn");
    const elLiveDot = document.getElementById("liveDot");
    const elLiveText = document.getElementById("liveText");
    const elCountNote = document.getElementById("countNote");

    function setLive(ok, msg){
      elLiveDot.classList.toggle("live", !!ok);
      elLiveText.textContent = msg || (ok ? "Live" : "Offline");
    }

    function hasVotedOnThisDevice(){
      return localStorage.getItem(LOCAL_LOCK_KEY) === "1";
    }
    function setVotedOnThisDevice(v){
      localStorage.setItem(LOCAL_LOCK_KEY, v ? "1" : "0");
    }

    function syncButtons(){
      if (hasVotedOnThisDevice()){
        elVote.disabled = true;
        elReVote.disabled = false;
        elSub.textContent = "Vote recorded on this device.";
      } else {
        elReVote.disabled = true;
        elVote.disabled = (selected.size === 0);
        elSub.textContent = "Select all that apply.";
      }
    }

    function buildOptions(options){
      // Don't wipe selections on refresh unless options truly changed
      elOptions.innerHTML = "";

      options.forEach((opt, idx) => {
        const wrap = document.createElement("div");
        wrap.className = "opt";
        wrap.setAttribute("role", "button");
        wrap.setAttribute("tabindex", "0");

        const badge = document.createElement("span");
        badge.className = "badge";
        badge.textContent = (opt.value || "").toString().trim() || String.fromCharCode(65 + idx);
        badge.style.background = `color-mix(in srgb, ${PALETTE[idx % PALETTE.length]} 75%, rgba(255,255,255,0.0))`;
        badge.style.borderColor = `color-mix(in srgb, ${PALETTE[idx % PALETTE.length]} 75%, rgba(255,255,255,0.0))`;

        const label = document.createElement("div");
        label.className = "label";
        label.textContent = opt.label;

        const val = String(opt.value).trim();

        function toggle(){
          // If they've already voted on this device, don't let them select until they hit "Change vote"
          if (hasVotedOnThisDevice()) return;

          if (selected.has(val)) selected.delete(val);
          else selected.add(val);

          wrap.classList.toggle("selected", selected.has(val));
          syncButtons();
        }

        wrap.addEventListener("click", toggle);
        wrap.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            toggle();
          }
        });

        // restore selection if present
        if (selected.has(val)) wrap.classList.add("selected");

        wrap.appendChild(badge);
        wrap.appendChild(label);
        elOptions.appendChild(wrap);
      });

      syncButtons();
    }

    function initChart(labels, counts){
      const ctx = document.getElementById("chart");
      chart = new Chart(ctx, {
        type: "bar",
        data: {
          labels,
          datasets: [{
            label: "Selections",
            data: counts,
            backgroundColor: labels.map((_, i) => PALETTE[i % PALETTE.length]),
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          plugins: { legend: { display: false } },
          scales: {
            x: { ticks: { color: "rgba(255,255,255,0.78)", font: { weight: 650 } }, grid: { display: false } },
            y: { beginAtZero: true, ticks: { color: "rgba(255,255,255,0.70)" }, grid: { color: "rgba(255,255,255,0.10)" } }
          }
        }
      });
    }

    function updateChart(labels, counts){
      if (!chart){ initChart(labels, counts); return; }
      chart.data.labels = labels;
      chart.data.datasets[0].data = counts;
      chart.data.datasets[0].backgroundColor = labels.map((_, i) => PALETTE[i % PALETTE.length]);
      chart.update();
    }

    async function apiGetPoll(){
      const url = `${SCRIPT_URL}?action=get&poll=${encodeURIComponent(POLL_ID)}&t=${Date.now()}`;
      const res = await fetch(url, { method: "GET" });
      if (!res.ok) throw new Error(`GET failed: ${res.status}`);
      return await res.json();
    }

    async function apiVoteMulti(values){
      const res = await fetch(SCRIPT_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ action: "vote_multi", poll: POLL_ID, values })
      });
      if (!res.ok) throw new Error(`POST vote_multi failed: ${res.status}`);
      return await res.json();
    }

    async function apiClear(adminCode){
      const res = await fetch(SCRIPT_URL, {
        method: "POST",
        headers: { "Content-Type": "text/plain;charset=utf-8" },
        body: JSON.stringify({ action: "clear", poll: POLL_ID, adminCode })
      });
      if (!res.ok) throw new Error(`POST clear failed: ${res.status}`);
      return await res.json();
    }

    async function loadInitial(){
      try{
        setLive(false, "Connecting…");
        const data = await apiGetPoll();
        poll = data;

        elQ.textContent = poll.question || "Untitled poll";

        buildOptions(poll.options || []);

        const labels = (poll.options || []).map(o => o.label);
        const counts = (poll.options || []).map(o => Number(o.count || 0));
        updateChart(labels, counts);

        const total = counts.reduce((a,b)=>a+b,0);
        elCountNote.textContent = `Total selections: ${total}`;
        setLive(true, "Live");
      } catch (e){
        console.error(e);
        setLive(false, "Offline");
        elQ.textContent = "Couldn’t load poll.";
        elSub.textContent = "Check SCRIPT_URL and POLL_ID (tab name).";
      }
    }

    async function refreshLoop(){
      try{
        const data = await apiGetPoll();
        poll = data;

        elQ.textContent = poll.question || "Untitled poll";

        // Only rebuild if the option VALUES or LABELS changed
        const existing = Array.from(elOptions.querySelectorAll(".label")).map(x => x.textContent).join("||");
        const incoming = (poll.options || []).map(o => o.label).join("||");
        if (existing !== incoming){
          // If options changed, clear selections that no longer exist
          const valid = new Set((poll.options || []).map(o => String(o.value).trim()));
          for (const v of Array.from(selected)) if (!valid.has(v)) selected.delete(v);
          buildOptions(poll.options || []);
        }

        const labels = (poll.options || []).map(o => o.label);
        const counts = (poll.options || []).map(o => Number(o.count || 0));
        updateChart(labels, counts);

        const total = counts.reduce((a,b)=>a+b,0);
        elCountNote.textContent = `Total selections: ${total}`;

        setLive(true, "Live");
      } catch (e){
        console.error(e);
        setLive(false, "Offline");
      }
    }

    elVote.addEventListener("click", async () => {
      if (selected.size === 0) return;
      elVote.disabled = true;
      try{
        const values = Array.from(selected);
        const out = await apiVoteMulti(values);
        if (!out || out.ok !== true) throw new Error(out && out.error ? out.error : "vote_multi failed");

        setVotedOnThisDevice(true);
        syncButtons();
        await refreshLoop();
      } catch (e){
        console.error(e);
        setVotedOnThisDevice(false);
        elSub.textContent = "Vote failed. Try again.";
        syncButtons();
      }
    });

    elReVote.addEventListener("click", () => {
      setVotedOnThisDevice(false);
      elSub.textContent = "Select all that apply.";
      syncButtons();
    });

    document.getElementById("secretClear").addEventListener("click", async () => {
      const adminCode = prompt("Instructor code to clear this poll:");
      if (!adminCode) return;
      try{
        const out = await apiClear(adminCode);
        if (out && out.ok){
          setVotedOnThisDevice(false);
          selected.clear();
          buildOptions(poll.options || []);
          await refreshLoop();
          alert("Cleared.");
        } else {
          alert("Wrong code (or clear failed).");
        }
      } catch (e){
        console.error(e);
        alert("Clear failed. Check deployment and code.");
      }
    });

    (async () => {
      await loadInitial();
      setInterval(refreshLoop, REFRESH_MS);
    })();
  </script>
</body>
</html>
